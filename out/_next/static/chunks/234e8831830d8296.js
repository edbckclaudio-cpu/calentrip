(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,51001,e=>{"use strict";var t=e.i(82568);class r{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getFromLocalDiskToStore(e){try{return await this.sqlite.getFromLocalDiskToStore({overwrite:null==e||e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async echo(e){try{let t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isSecretStored(){try{let e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{let t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async createConnection(e,t,r,a,i){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:a,readonly:i});let n=new s(e,i,this.sqlite),o=i?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(o,n),Promise.resolve(n)}catch(e){return Promise.reject(e)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});let r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(e){return Promise.reject(e)}}async isConnection(e,t){let r={};e.endsWith(".db")&&(e=e.slice(0,-3));let s=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(s),Promise.resolve(r)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));let r=t?`RO_${e}`:`RW_${e}`;if(!this._connectionDict.has(r))return Promise.reject(`Connection ${e} does not exist`);{let t=this._connectionDict.get(r);return void 0!==t?Promise.resolve(t):Promise.reject(`Connection ${e} is undefined`)}}async getNCDatabasePath(e,t){try{let r=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});let r=new s(e,!0,this.sqlite),a=`RO_${e})`;return this._connectionDict.set(a,r),Promise.resolve(r)}catch(e){return Promise.reject(e)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});let t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(e){return Promise.reject(e)}}async isNCConnection(e){let t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)}async retrieveNCConnection(e){if(!this._connectionDict.has(e))return Promise.reject(`Connection ${e} does not exist`);{let t=`RO_${e})`,r=this._connectionDict.get(t);return void 0!==r?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}}async isNCDatabase(e){try{let t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){let e=new Map;try{for(let t of this._connectionDict.keys()){let r=t.substring(3),s="RO_"===t.substring(0,3);await this.sqlite.closeConnection({database:r,readonly:s}),e.set(t,null)}for(let t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(e){return Promise.reject(e)}}async checkConnectionsConsistency(){try{let e=[...this._connectionDict.keys()],t=[],r=[];for(let s of e)t.push(s.substring(0,2)),r.push(s.substring(3));let s=await this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return s.result||(this._connectionDict=new Map),Promise.resolve(s)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{let t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isJsonValid(e){try{let t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async copyFromAssets(e){try{return await this.sqlite.copyFromAssets({overwrite:null==e||e}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getFromHTTPRequest(e,t){try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:null==t||t}),Promise.resolve()}catch(e){return Promise.reject(e)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{let t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isInConfigEncryption(){try{let e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{let e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{let t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async getDatabaseList(){try{let e=(await this.sqlite.getDatabaseList()).values;return e.sort(),Promise.resolve({values:e})}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){try{let t=await this.sqlite.getMigratableDbList({folderPath:e||"default"});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async addSQLiteSuffix(e,t){try{let r=await this.sqlite.addSQLiteSuffix({folderPath:e||"default",dbNameList:t||[]});return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async deleteOldDatabases(e,t){try{let r=await this.sqlite.deleteOldDatabases({folderPath:e||"default",dbNameList:t||[]});return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async moveDatabasesAndAddSuffix(e,t){return this.sqlite.moveDatabasesAndAddSuffix({folderPath:e||"default",dbNameList:t||[]})}}class s{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{let e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{let e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{let e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{let e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async getUrl(){try{let e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{let e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{let e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,r=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{let s=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(s)}}catch(e){return Promise.reject(e)}}async query(e,t,r=!0){let s;try{return s=t&&t.length>0?await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),s=await this.reorderRows(s),Promise.resolve(s)}catch(e){return Promise.reject(e)}}async run(e,t,r=!0,s="no",a=!0){let i;try{if(!this.readonly)return(i=t&&t.length>0?await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:s,isSQL92:!0}):await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:s,isSQL92:a})).changes=await this.reorderRows(i.changes),Promise.resolve(i);return Promise.reject("not allowed in read-only mode")}catch(e){return Promise.reject(e)}}async executeSet(e,t=!0,r="no",s=!0){let a;try{if(!this.readonly)return(a=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:s})).changes=await this.reorderRows(a.changes),Promise.resolve(a);return Promise.reject("not allowed in read-only mode")}catch(e){return Promise.reject(e)}}async isExists(){try{let e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{let t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async isDBOpen(){try{let e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{if(!this.readonly)return await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve();return Promise.reject("not allowed in read-only mode")}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{let e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{if(!this.readonly)return await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve();return Promise.reject("not allowed in read-only mode")}catch(e){return Promise.reject(e)}}async getSyncDate(){try{let e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly}),t="";return e.syncDate>0&&(t=new Date(1e3*e.syncDate).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{let r=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async deleteExportedRows(){try{if(!this.readonly)return await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve();return Promise.reject("not allowed in read-only mode")}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let r=0;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),!await this.sqlite.isTransactionActive({database:this.dbName}))return Promise.reject("After Begin Transaction, no transaction active");try{for(let s of e){if("object"!=typeof s||!("statement"in s))throw Error("Error a task.statement must be provided");if("values"in s&&s.values&&s.values.length>0){let e=s.statement.toUpperCase().includes("RETURNING")?"all":"no",a=await this.sqlite.run({database:this.dbName,statement:s.statement,values:s.values,transaction:!1,readonly:!1,returnMode:e,isSQL92:t});if(a.changes.changes<0)throw Error("Error in transaction method run ");r+=a.changes.changes}else{let e=await this.sqlite.execute({database:this.dbName,statements:s.statement,transaction:!1,readonly:!1});if(e.changes.changes<0)throw Error("Error in transaction method execute ");r+=e.changes.changes}}let s=await this.sqlite.commitTransaction({database:this.dbName}),a={changes:{changes:r+=s.changes.changes}};return Promise.resolve(a)}catch(t){let e=t.message?t.message:t;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(e)}}async reorderRows(e){if(e?.values&&"object"==typeof e.values[0]&&Object.keys(e.values[0]).includes("ios_columns")){let t=e.values[0].ios_columns,r=[];for(let s=1;s<e.values.length;s++){let a=e.values[s],i={};for(let e of t)i[e]=a[e];r.push(i)}e.values=r}return Promise.resolve(e)}}e.s(["SQLiteConnection",()=>r,"SQLiteDBConnection",()=>s],16417);let a=(0,t.registerPlugin)("CapacitorSQLite",{web:()=>e.A(29126).then(e=>new e.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});e.s(["CapacitorSQLite",()=>a],30961),e.i(30961),e.i(16417),e.s(["CapacitorSQLite",()=>a,"SQLiteConnection",()=>r,"SQLiteDBConnection",()=>s],51001)},29126,e=>{e.v(t=>Promise.all(["static/chunks/e09f8247237eb634.js"].map(t=>e.l(t))).then(()=>t(25874)))}]);